[TOC]



### CP1

#### 排序和过滤

**排序方式**

**1.**C#中我们可以通过实现 IComparer（官网推荐使用继承Comparer<T>来代替实现ICompare接口） 和 IComparable 来实现自定义排序规则。

IComparer需要实现Compare函数、IComparable需要实现CompareTo函数。一般返回值为-1(排在形参前)，0，1。有一种说法：实现IComparer能够定义多种排序规则；而实现IComparable只能定义一种排序规则。

起先我是不太理解的，因为既然都是自定义比较方式，怎么就有差别了呢？这里是我没有搞明白这两个接口适用对象。

- 实现 IComparable 的对象， 应该叫做 “数据可比较对象”，因为它要实现的CompareTo函数是将这些数据直接比较的。
- 实现 IComparer （或者继承自Comparer）的对象， 应该叫做 “比较器” ，它可以被用于集合的Sort策略或者直接比较两个 “数据可比较对象”得出它们前后关系。所以可以用不同的比较器实现不同排序策略。
- [示例](!https://docs.microsoft.com/zh-cn/dotnet/api/system.collections.generic.comparer-1?view=netframework-4.7.2)

**2.**使用委托定义排序的匿名方法

```c#
list.Sort(delegate(Product x,Product y){ return x.Name.CompareTo(y.Name)})
```

**3.**使用lamda表达式定义排序（2方式的语法糖）

```
list.Sort((x,y) => {x.Name.CompareTo(y.Name)})
```

**4.**使用Linq，有个问题就是慢

```
foreach (Product p in list.OrderBy(item => item.Name))
```

**查询**

C#1中使用基础的 for/foreach 遍历 ,foreach涉及拆装箱速度比for慢些。

C#3以后可以使用集合的Find函数结合lamda

#### 处理未知数据

C#2.0之后引入了Nullable<T>结构，在可空类型后加上？声明可空对象：int?、Integer?、bool?等，可以通过HasValue判断是否有值。

#### ref 、 out、pramas

- ref 需要传入的值必须初始化过，且调用、声明时都要指定关键字
- out 传入不需要初始化，但是传出一定要初始化，调用、声明要指定关键字
- params 不定数目的参数，且参数必须是参数表中的最后一个参数。

#### 与动态语言的互操作性

C#4的新类型dynamic，编译器允许我们动态地使用该类型。如果一个表达式为dynamic类型，我们可以调用其方法、访问其属性、将其作为方法的参数进行传递，等等。我们可以将dynamic类型的值隐式转换为其他类型。

### CP2

#### 委托

**委托的构成**

为了让委托做某事，必须满足4个条件

- 声明委托类型
- 必须有一个方法包含了要执行的代码
- 必须创建一个委托实例
- 必须调用委托实例

**注意**：在声明好委托后，给委托指定的方法要匹配三点：

- 返回值类型相同
- 形参个数相同
- 形参类型相同，可以兼容基类类型

**合并和删除委托**

需要说明的是

- <u>*委托的不易变的*</u>（这点类似string）。它可以调用 “ += / -= ”操作符将两个委托的调用列表合<u>*并且实例化一个新的委托*。</u>这并不改变原来的对象。
- 非void得委托列表然会值由最后一个操作得返回值决定
- 任何操作发生异常，后续操作都不会被执行

#### 值类型/引用类型

**走出误区**

1. “结构是轻量级的类”

   产生这个想法的可能有两点：

   - 有人认为值类型不能或不应该由方法或者其他由意义的行为——它们应该作为简单的数据转移类型来使用，之应该有public 字段或简单的属性。这种说法的反例就可以有DateTime类型，虽然因它实现了很多接口因此有了方法，但是它依然是值类型。
   - 还有些人认为值类型之所以比引用类型 “轻”，是因为性能。事实是在某些情况下，值类型很 “能干” ——它们不需要垃圾回收（除非被拆装箱），也不需要解引用。但是在其他方面，引用类型显得更能干——在传递参数、赋值、将值返回和执行类似的操作时，只需要复制4/8字节（32位/64位CLR）的引用，而不是复制全部数据。

2. “引用类型保存在堆上，值类型保存在栈上”

   前半部分没什么问题，问题出在后半部分。**变量的值是在它声明的位置储存的**。所以，假定一个类中有一个int类型的实例变量，那么在这个类的任何对象中，该变量的值总是和对象中的其他值在一起，也就是在堆上。**只有局部变量和方法参数在栈上。**不过对于C#2+版本，很多局部变量并不完全在栈中，比如捕获变量在被捕获并延长生命周期后，它其实不在栈上，而是由编译器创建的一个额外的类来容纳，所以它是被存放在堆上的。

3. “对象在C#中是通过引用传递的”

   典型得没有理解什么是引用传递（所谓**引用传递**是指在调用函数时将实际参数的地址传递到函数中，那么在函数中对参数所进行的修改，将影响到实际参数，C#中有ref 、out。）。其次引用类型储存的值是引用，而不是对象本身，对象之间能传递的只是引用。

