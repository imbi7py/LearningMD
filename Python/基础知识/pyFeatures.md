# 特性

### 迭代

 for..in..      (类似foreach)
 enumerate      (带下标迭代)
 isinstance     (判断是否可迭代)
### 列表生成式   （受内存限制，容量有限->生成器）

### 生成器       （按照一定公式计算，一边循环一边计算）、生成器是一个可迭代对象
    - 几种改成生成器的方法： 1.列表推导式把[]改成（） 、 2.把循环输出函数中的输出语句替换成yield语句
    - 与迭代器关系：生成器是一个返回迭代器的函数，只能用于迭代操作，更简单点理解生成器就是一个迭代器。
### 迭代器
    - 凡是可作用于for循环的对象都是Iterable类型；
    - 凡是可作用于next()函数的对象都是Iterator类型，它们表示一个惰性计算的序列； 
    - 序列数据类型不是Iterator
    - 把类作为迭代对象需要定义__iter__() 和 __next__()
### 模块
    - 模块之间避免重名，如果重名，可以将模块置入一个文件下，然后在文件下新增一个__init_.py文件，这样就把模块放在了包（package）下了。
    - __init__.py可以是空文件，也可以包含代码，加入上述包名叫mypack，这个__init__.py实际上是一个叫mypack的模块，而原来重名的模块名就会变成 mymodual.mypack
    - 类似的可以有多层级的包结构
    - import时发生了什么？
             - 为源代码文件中定义的对象创建一个名字空间，通过这个名字空间可以访问到模块中定义的函数和变量
             - 在新创建的名字空间里执行源代码文件
             - 创建一个名为源代码文件的对象，该对象引用模块的名字空间，这样就可以通过这个对象访问模块中的函数和变量
             - 概括一下：创建名字空间，执行名字空间下的源文件，创建源文件对象引用模块名字空间
### 异常处理
    - 可以跨层捕获异常。比如函数main()调用foo()，foo()调用bar()，结果bar()出错了，这时，只要main()捕获到了，就可以处理：
    - logging模块记录错误信息，同时让程序不被终止继续执行
    - raise 可以抛出一个错误           
    - 格式：try:<body> exception Exception as e: <Do>
### 面向对象

#### 类和对象 
    - 类方法参数列表第一个永远是self，但是传参的时候不用指定
    - 类对象可以随时增加新变量，这个叫实例属性，类中单独定义的变量叫做类属性（所有实例共享）。调用类属性： 类名.属性名。调用实例属性：self.属性名
    - 添加私用变量，在变量前加__,外部访问修改的话定义get_xx,set_xx，set时参数列表第一个永远是self,getter/setter器return出去的一定是 self.xx
    - __xx__变量是特殊变量，可以直接访问
    - _X,虽然可以直接外部访问，当时把他当私有变量不要直接访问

#### 继承
    - 类名后括号中指定基类
    - 子类多态只要定义重名函数即可
    - 面向基类编程中，只要传入类型拥有和基类一样需要的函数就可执行，不一定像Java那样必须是基类或子类
    ```
    class A(object):
        def run(self):
            print('A run')
    class B(A):
        def run(self):
            print('B run')
    class C(object):
        def run(self):
            print('C run')
    def do(A):
        A.run
    do(B())
    do(C())    #即使不是A的子类也可以，这个特性叫做动态语言的“鸭子类型”
    ```

#### 多重继承

多重继承中子类继承列表中的继承循序将影响同名函数的调用：根据mro查找顺序，执行第一个找到的同名函数，即第一个父类的同名函数



### 魔法方法

\_ _ _repr\_ _  和 _ _ str_ _ _  的异同:

- 同：都能用来定义类对象的说明
- 异：定义了repr后直接调用对象就会输出自定义的对象说明，也可以通过print打印对象说明；str只能通过print打印对象说明

