### 迭代器

基本迭代过程

```python
>>> items = [1, 2, 3]
>>> # Get the iterator
>>> it = iter(items) # Invokes items.__iter__()
>>> # Run the iterator
>>> next(it) # Invokes it.__next__()
1
>>> next(it)
2
>>> next(it)
3
>>> next(it)
Traceback (most recent call last):
    File "<stdin>", line 1, in <module>
StopIteration   # 通过报错通知迭代结束，也可用使用next(iter,None)将无可迭代返回None
```

#### 要点整理

1. 让容器能够完成迭代操作要实现`__iter__()`，如果要能反向迭代就需要实现`__reversed__()`，这个过程叫实现迭代协议。
2. 内置函数`iter`生成的迭代器对象类型是根据原始序列决定的。例如将列表转为迭代器对象，那个这个对象就是`list_iterator`类型的。
3. 正常流程结束会报StopIteration Error， 可以设置`next`默认值来避免报错。`for`语句为迭代已经做了特殊处理，所以可以不担心报错
4. 用`next()`直接调用实现迭代协议的类实例，会报TypeError。如果要使用除了for以外的迭代操作，需要先使用`iter()`将类对象转化一下，再迭代。



### 使用生成器辅助迭代

例子1：生成一个倒数的序列

```python
>>> def countdown(n):
...     while n > 0:
...         yield n
...         n -= 1
...     print('Done!')
>>> for i in countdown(10):
...     print('Starting to count from', i)    	
```

一个函数中需要有一个 `yield` 语句即可将其转换为一个生成器。生成器只能响应迭代操作。

例子2：生成器额外生成状态

```python
def __iter__(self):
        for lineno, line in enumerate(self.lines, 1):
            self.history.append((lineno, line))
            yield line
```

将生成数据保存至内部额外容器中，外部迭代这个容器即可。

### 使用[itertools模块](<https://docs.python.org/zh-cn/3/library/itertools.html?highlight=itertools>)辅助迭代

例子1：做迭代器做切片操作

```python
>>> def count(n):
...     while True:
...         yield n
...         n += 1
...
>>> c = count(0)
>>> c[10:20]
Traceback (most recent call last):
    File "<stdin>", line 1, in <module>
TypeError: 'generator' object is not subscriptable

>>> # Now using islice()
>>> import itertools
>>> for x in itertools.islice(c, 10, 20):
...     print(x)
...
10
11
12
13
14
15
16
17
18
19
>>>
```

迭代器/生成器是没办法执行普通切片操作的，这是因为他们不知道数据有多长（而且他们也没有实现索引）。`itertools.islice`本身产生的结果也是一个迭代器，他是通过丢弃前部数据，和计算迭代次数实现切片的。因此，这种迭代是会遗失数据的，需要额外将数据保存到其他容器中。

例子2：跳过前部数据：itertools.dropwhile