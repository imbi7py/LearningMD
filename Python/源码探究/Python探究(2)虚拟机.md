[TOC]

## 回顾前文

`python`中的`module`最开始对应的其实是一个`py`文件，再由虚拟机编译成一个`Internal`对象。通过前文我们了解了`python`的对象系统，本文来了解一下`py`文件的编译，以及虚拟机相关内容。

## .py文件转变

我们在执行**py文件**的时候会激活**python解释器**去编译文件代码，编译产生的字节码，再交给**Python虚拟机**按序执行。

### 编译结果

python代码经过解释器编译得到的内容，准确来说不只是字节码，还包含一些源代码中的静态信息。

这些静态信息是由解释器在运行时，从源代码中收集的（常量，字符串等），它们会被暂时储存在**PyCodeObject**中，在Python运行结束后，`PyCodeObject`的内容会被保存到**pyc文件**。

所以，`PyCodeObject`才是解释器的主要  编译结果，`pyc`文件只是保存到硬盘的形式，供下次运行快速在内存中直接创建PyCodeObject对象。

- **那么PyCodeObject的创建规则是怎样的呢？**

  当编译到一个新的名字空间时，就会创建一个`PyCodeObject`去对应这块代码。和作用域存在包含关系一样，`PyCodeObject`也存在包含关系。`PyCodeObject`在写到pyc的过程中如果发现有包含的其他`PyCodeObject`就会递归的执行写入。

- **pyc文件的产生**

  在交互式环境中，由于代码的运行需求是临时性的所以不会产生pyc文件。而`.py`文件中加入了`import`,就会触发创建pyc文件，这个pyc文件对应的就是被导入的模块的信息。

- **pyc文件包含的内容**

  - `magic_number`：不同的python版本`magic_number`也不同，`python`不会加载不属于自己版本`magic_number`的`pyc`文件。
  - 时间：`py`文件和`pyc`文件时间修改时间不同，会导致重现创建`pyc`文件。
  - `PyCodeObject`：源代码经过编译处理的对象。这里面的数据写到`pyc`时会以类型+值的方式写入，因为变成二进制数据会丢失类型信息。
  
- **字节码**

  字节码对应的就是源代码中的一种操作。

## 虚拟机

### 运行机理

前文说过，编译好的字节码会交给虚拟机**按序执行**，那么虚拟机是怎么实现**按序**的呢？

首先，抛开虚拟机，操作系统在运行可执行文件的时候会创建一个运行时栈，在运行时栈中存在一个叫做**栈帧**的概念，即函数执行环境，这里面保存了上一个栈帧的**栈指针**和**帧指针**，这使得程序流程在执行完函数后能够返回上一层的状态。

而`python`虚拟机做的就是对这一过程的模拟，它给出的栈帧实现是`PyFrameObject`。

## 问题回顾

本文我们知道一个`py`文件（即`module`的硬盘表现形式）通过虚拟机的编译会形成一个或多个`PyCodeObject`,这里面包含了字节码及一些静态信息，虚拟机通过`PyFrameObject`能够保证字节码以正确顺序执行。

结合上一文，我们知道可引用的模块对象是属于虚拟机内部使用的一种对象；本文我们知道了模块对应的代码怎么被编译到运行时环境。此时我们仿佛知道了开头和结尾，但是对于中间部分依然毫无所知，那么中间到底做了什么呢？

下文直接针对`module`这个概念做了解。