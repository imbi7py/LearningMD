### 阅前疑问

- 内存管理涉及哪些部分?
- 垃圾回收策略是怎样的？
- 做了哪些性能优化上的处理？
  1. 在内存管理上使用宏，避免函数调的消耗，同时也提供同义函数供C编写扩展时使用。
  2. 创建小块空间内存管理策略，避免频繁操作内存产生消耗。

### 内存管理架构

![Python内存管理全景](img\Python内存管理全景.png)

### 小块空间内存管理

![小块空间内存管理](img\小块空间内存管理.png)

为了在32位/64位操作系统上都获得最佳性能，小块空间内存池的block采用8字节对齐。

一组block称为pool。python中没有实体与block对应，但是有pool的对应实体：pool_header结构体,但它其实只是pool的一部分。

block会存在频繁的申请和释放，可用内存离散分布，为了提高零散内存的使用率，Python建立了block链表，并由pool_header中的freeblock处理，因为freeblock指向的是一个有效的地址（下一个分配给block的地址），当一个block被释放时，freeblock将会指向最新被释放的block地址。

多个pool的集合被称为arena，对应的是arena_object结构体。不同于pool_header被申请时同时会申请block集合内存，arena_object和pool集合申请时机并不是同步的。只有在arena_object和pool集合建立联系的时候才会申请pool内存，这个时候称arena为“可用的”。

![pool和arena内存分布区别](img\pool和arena内存分布区别.png)

在申请arena内存的时候会先去寻找“未使用”的，否则再去申请一块arena内存。

最上层的内存池策略其实是对`pool`池的管理策略，

### 垃圾收集策略

- 引用计数（即时性最高）

任何内存，一旦没有指向它的引用，就会被立即回收。但是引用技术策略带来的额外维护操作拉低了python的运行效率，所以python中存在大量的内存池策略与之搭配，只为了减少这个负面影响。引用计数有个致命缺陷就是无法解决循环引用问题，一旦出现循环引用，这块内存一直无法释放直到Python结束生命周期。

- 三色标记模型（标记-清除）
  1. 起点：寻找根对象（全局引用、函数栈中的引用），引用对象都不可删除。
  2. 从根对象集合出发，如果能沿着引用到达具体对象，则称对象可达，否则划分为不可达
  3. 回收所有不可达对象占用的内存。

**注：**这种方式的垃圾收集操作与系统总内存块数量相关，内存块越多，检查的越多，操作也越多。

为了避免循环引用对标记-清除策略的影响，在沿着引用检查时会将引用对象的计数副本（gc.gc_ref）-1。这样存在循环引用时，起先两者引用数都为1，但是-1之后就变成0了。

- 可收集对象链表

为了检测可能产生循环引用的容器对象，Python用双向链表实现了一个“可收集对象链表”，创建的容器类型对象都会被插入这个链表。

![gc_head](img\gc_head.png)

在创建容器类对象时，会先通过`_PyObject_GC_New`为PyGC_Head申请内存，然后才给容器对象申请内存。

![contianer](img\contianer.png)

创建一个容器类型对象的最后一部会通过`_PyObject_GC_TRACK`和`_PyObject_GC_UNTRACK`来实现向可收集对象链表中增加和删除。与此同时，会增加0分代数量，是后续出发分代垃圾回收的依据。

- 分代收集策略

为了更好的服务于“标记-清除”策略，Python将内存块根据其存活时间划分为不同集合（一代），**垃圾收集的频率随着 “ 代 ” 的存活时间增大而减少。 ** 主要思想：减少每次垃圾回收要检测的内存数量，以空间换时间。

Python将内存生命周期分为三代，每一代都是一个链表（可收集对象链表）。

![gc分代](img\gc分代.png)

第0代的最大值是700个可收集对象，当超过这个数就会触发一次GC。这次GC会去寻找所有分代中年满足回收条件的最大分代，然后从大到小对分代依次执行GC。

### 垃圾回收的一些痛点

- 不能保证回收顺序