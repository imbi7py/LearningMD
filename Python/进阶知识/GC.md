### 一.垃圾回收机制
Python中的垃圾回收是以引用计数为主，分代收集为辅。引用计数的缺陷是循环引用的问题。
在Python中，如果一个对象的引用数为0，Python虚拟机就会回收这个对象的内存。
#### 引用变动
    1. 导致引用计数+1的情况
        对象被创建，例如a=23
        对象被引用，例如b=a
        对象被作为参数，传入到一个函数中，例如func(a)
        对象作为一个元素，存储在容器中，例如list1=[a,a]
        2. 导致引用计数-1的情况
        对象的别名被显式销毁，例如del a
        对象的别名被赋予新的对象，例如a=24
        一个对象离开它的作用域，例如f函数执行完毕时，func函数中的局部变量（全局变量不会）
        对象所在的容器被销毁，或从容器中删除对象
### 二.循环引用导致内存泄露
### 三.垃圾回收

- 垃圾回收后的对象会放在gc.garbage列表里面
- gc.collect()会返回不可达的对象数目，4等于两个对象以及它们对应的dict
- 有三种情况会触发垃圾回收：
    1.调用gc.collect(),
    2.当gc模块的计数器达到阀值的时候。
    3.程序退出的时候

### 四.gc模块常用功能解析
gc模块提供一个接口给开发者设置垃圾回收的选项。上面说到，采用引用计数的方法管理内存的一个缺陷是循环引用，而gc模块的一个主要功能就是解决循环引用的问题。

#### 常用函数：

- gc.set_debug(flags)
  设置gc的debug日志，一般设置为gc.DEBUG_LEAK
- gc.collect([generation])
  显式进行垃圾回收，可以输入参数，0代表只检查第一代的对象，1代表检查一，二代的对象，2代表检查一，二，三代的对象，如果不传参数，执行一个full collection，也就是等于传2。返回不可达（unreachable objects）对象的数目
- gc.set_threshold(threshold0[, threshold1[, threshold2])
  设置自动执行垃圾回收的频率。
- gc.get_count()
  获取当前自动执行垃圾回收的计数器，返回一个长度为3的列表