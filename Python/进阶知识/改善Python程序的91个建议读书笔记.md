编写高质量代码：改善Python程序的91个建议
张颖 赖勇浩
149个笔记


◆ 建议8：利用assert语句来发现问题

断言一般总在单元测试中

>> 对Python中使用断言需要说明如下：
1）__debug__的值默认设置为True，且是只读的，在Python2.7中还无法修改该值。
2）断言是有代价的，它会对性能产生一定的影响，对于编译型的语言，如C/C++，这也许并不那么重要，因为断言只在调试模式下启用。但Python并没有严格定义调试和发布模式之间的区别，通常禁用断言的方法是在运行脚本的时候加上-O标志，这种方式带来的影响是它并不优化字节码，而是忽略与断言相关的语句

断言实际是被设计用来捕获用户所定义的约束的，而不是用来捕获程序本身错误的，因此使用断言需要注意以下几点：
1）不要滥用，这是使用断言最基本的原则。若由于断言引发了异常，通常代表程序中存在bug。因此断言应该使用在正常逻辑不可到达的地方或正常情况下总是为真的场合。
2）如果Python本身的异常能够处理就不要再使用断言。如对于类似于数组越界、类型不匹配、除数为0之类的错误，不建议使用断言来进行处理。下面的例子中使用断言就显得多余，因为如果传入的参数一个为字符串，另一个为数字或者列表，本身就会抛出TypeError

3）不要使用断言来检查用户的输入。

4）在函数调用后，当需要确认返回值是否合理时可以使用断言。
5）当条件是业务逻辑继续下去的先决条件时可以使用断言


◆ 建议10：充分利用Lazy evaluation的特性

1）避免不必要的计算，带来性能上的提升。

2）节省空间，使得无限循环的数据结构成为可能。


◆ 建议11：理解枚举替代实现的缺陷

使用类属性。

```
class Seasons: 
    Spring,Summer,Autumn,Winter=range(4) 
```

2）借助函数。

```
def enum(*posarg, keysarg): 
...     return type("Enum", (object,), dict(zip(posarg, xrange(len(posarg))),  
keysarg)) 
... 
Seasons = enum("Spring","Summer","Autumn",Winter=1) 
Seasons.Spring 
0
```

3）使用collections.namedtuple。

```
Seasons = namedtuple('Seasons','Spring Summer Autumn Winter')._make(range(4)) 
print Seasons.Spring 
# 0
```

值得一提的是，Python3.4中根据PEP435的建议终于加入了枚举Enum，其实现主要参考实现flufl.enum


◆ 建议12：不推荐使用type来进行类型检查

类型判断建议使用isinstance函数

作为动态性的强类型脚本语言，Python中的变量在定义的时候并不会指明具体类型，Python解释器会在运行时自动进行类型检查并根据需要进行隐式类型转换

基于内建类型扩展的用户自定义类型，type函数并不能准确返回结果。

在古典类中，任意类的实例的type()返回结果都是<type 'instance'>。这种情况下使用type()函数来确定两个变量类型是否相同显然结果会与我们所理解的大相径庭。


◆ 建议13：尽量转换为浮点类型后再做除法

ython3之前的版本可以通过from __future__ import division机制使整数除法不再截断，这样即使不进行浮点类型转换，输出结果也是正确的

因为在计算机的世界里，浮点数的存储规则决定了不是所有的浮点数都能准确表示，有些是不准确的，只是无限接近。如0.1转换为二进制表示形式则为0.000110011001……后面1001无限循环。在内存中根据浮点数位数规定，多余部分直接截断，

对于浮点数的处理，要记住其运算结果可能并不是完全准确的。

精度要求较高，可以使用Decimal来进行处理或者将浮点数尽量扩大为整数，计算完毕之后再转换回去。


◆ 建议14：警惕eval()的安全漏洞

Python中eval()函数将字符串str当成有效的表达式来求值并返回计算结果。


◆ 建议15：使用enumerate()获取序列迭代的索引和值

建议15：使用enumerate()获取序列迭代的索引和值


◆ 建议16：分清 == 与is的适用场景

建议16：分清 == 与 is的适用场景


◆ 建议17：考虑兼容性，尽可能使用Unicode

Python内建的字符串有两种类型：str和Unicode，它们拥有共同的祖先basestring。

Unicode为不同语言设置了唯一的二进制表示形式，可以轻易地解决不同字符集之间的字符映射问题，因此要解决示例一的乱码问题可以使用Unicode作为中间介质来完成转换。首先需要对读入的字符用UTF-8进行解码，然后再用GBK进行编码。


◆ 建议19：有节制地使用from...import语句

而解决循环嵌套导入问题的一个方法是直接使用import语句。读者可以自行验证。


◆ 建议20：优先使用absolute import来导入模块

ValueError: Attempted relative import in non-package”


◆ 建议22：使用with自动关闭资源

包含有with语句的代码块的执行过程如下：
1）计算表达式的值，返回一个上下文管理器对象。
2）加载上下文管理器对象的__exit__()方法以备后用。
3）调用上下文管理器对象的__enter__()方法。
4）如果with语句中设置了目标对象，则将__enter__()方法的返回值赋值给目标对象。
5）执行with中的代码块。
6）如果步骤5中代码正常结束，调用上下文管理器对象的_exit__()方法，其返回值直接忽略。
7）如果步骤5中代码执行过程中发生异常，调用上下文管理器对象的_exit__()方法，并将异常类型、值及traceback信息作为参数传递给__exit__()方法。如果_exit__()返回值为false，则异常会被重新抛出；如果其返回值为true，异常被挂起，程序继续执行。

在文件处理时使用with的好处在于无论程序以何种方式跳出with块，总能保证文件被正确关闭。

实际上任何实现了上下文协议的对象都可以称为一个上下文管理器，文件也是实现了这个协议的上下文管理器，它们都能够与with语句兼容。文

用户也可以定义自己的上下文管理器来控制程序的运行，只需要实现上下文协议便能够和with语句一起使用。

```
class MyContextManager(object): 
...     def enter(self):# 实现enter 方法 
...             print "entering..." 
...     def exit(self,exception_type, exception_value, traceback): 
...             print "leaving..." 
...             if exception_type is None: 
...                     print "no exceptions!" 
...                     return False 
...             elif exception_type is ValueError: 
...                     print "value error!!!" 
...                     return True 
...             else: 
...                     print "other error" 
...                     return True 
... 

with MyContextManager(): 
...     print "Testing..." 
...     raise(ValueError) 
... 
entering... 
Testing... 
leaving... 
value error!!! 

with MyContextManager(): 
...     print "Testing..." 
... 
entering... 
Testing... 
leaving... 
no exceptions! 
```

◆ 建议23：使用else子句简化循环（异常处理）

当循环“自然”终结（循环条件为假）时else从句会被执行一次，而当循环是由break语句中断时，else子句就不被执行。


◆ 建议24：遵循异常处理的几点基本原则

异常处理通常需要遵循以下几点基本原则：
1）注意异常的粒度，不推荐在try中放入过多的代码。异常的粒度是人为划分的，在处理异常的时候最好保持异常粒度的一致性和合理性，同时要避免在try中放入过多的代码，即避免异常粒度过大。

2）谨慎使用单独的except语句处理所有异常，最好能定位具体的异常。

如果在某些情况下不得不使用单独的except语句，最好能够使用raise语句将异常抛出向上层传递。

3）注意异常捕获的顺序，在合适的层次处理异常。

4）使用更为友好的异常信息，遵守异常参数的规范。


◆ 建议25：避免finally中可能发生的陷阱

当try块中发生异常的时候，如果在except语句中找不到对应的异常处理，异常将会被临时保存起来，当finally执行完毕的时候，临时保存的异常将会再次被抛出，但如果finally语句中产生了新的异常或者执行了return或者break语句，那么临时保存的异常将会被丢失，从而导致异常屏蔽。

这是因为a>0，会执行else分支，但由于存在finally语句，在执行else语句的return a语句之前会先执行finally中的语句，此时由于finally语句中有return -1，程序直接返回了，所以永远不会返回a对应的值2。

在实际应用程序开发过程中，并不推荐在finally中使用return语句进行返回，这种处理方式不仅会带来误解而且可能会引起非常严重的错误。


◆ 建议27：连接字符串应优先使用join而不是+

所以字符串的连接时间复杂度近似为O(n^2)。

而当用join()方法连接字符串的时候，会首先计算需要申请的总的内存空间，然后一次性申请所需内存并将字符序列中的每一个元素复制到内存中去，所以join操作的时间复杂度为O(n)。


◆ 建议28：格式化字符串时尽量使用.format方式而不是%

对于%直接格式化字符的这种形式，如果字符本身为元组，则需要使用在%使用(itemname,)这种形式才能避免错误，注意逗号


◆ 建议29：区别对待可变对象和不可变对象

深浅拷贝都是对源对象的复制，占用不同的内存空间
如果源对象只有一级目录的话，源做任何改动，不影响深浅拷贝对象
如果源对象不止一级目录的话，源做任何改动，都要影响浅拷贝，但不影响深拷贝
序列对象的切片其实是浅拷贝，即只拷贝顶级的对象。
文中举得例子不足以说明拷贝问题，只是想说明Python中一切皆为对象，对象保存的是引用，我们要注意可变对象和不可变对象赋引用的区别，也就是这个等号背后的含义。

可变参数不作默认值，一般设None
我们在将可变对象作为函数默认参数的时候要特别警惕的问题，对可变对象的更改会直接影响原对象

我们在将可变对象作为函数默认参数的时候要特别警惕的问题，对可变对象的更改会直接影响原对象

实际上Python中变量a存放的是数值1在内存中的地址，数值1本身才是不可变对象。在上面的过程中所改变的是a所指向的对象的地址，数值1并没有发生改变，当执行a+=2的时候重新分配了一块内存地址存放结果，并将a的引用改为该内存地址


◆ 建议30：[]、()和{}：一致的容器初始化形式

列表元组字典都可以使用类似的表达式快速生成

但需要注意，因为元组也适用赋值语句的装箱和拆箱机制，所以需要注意（1）与（1,）是不同的：前者为数字1，后者才代表元组（注意1后面的“,”）。


◆ 建议31：记住函数传参既不是传值也不是传引用

python的变量保存的是指向对象内存地址的指针

◆ 建议32：警惕默认参数潜在的问题

> 参数列表中的默认参数不能包含可变类型，应该用None替代


◆ 建议33：慎用变长参数

1. 变长参数意味着这个函数的签名不够清晰，存在多种调用方式。如果调用者需要花费过多的时间来研究你的方法该如何调用，显然这并不是一种值得提倡的方式

2. 如果一个函数的参数列表很长，虽然可以通过使用*args和**kwargs来简化函数的定义，但通常这意味着这个函数可以有更好的实现方式，应该被重构


◆ 建议34：深入理解str()和repr()的区别

> repr()和str()对于大多数数据类型的输出基本一致，
>
> 那么，这两者之间到底有什么区别呢？总结来说有以下几点：
> 1）两者之间的目标不同：str()主要面向用户，其目的是可读性，返回形式为用户友好性和可读性都较强的字符串类型；而repr()面向的是Python解释器，或者说开发人员，其目的是准确性，其返回值表示Python解释器内部的含义，常作为编程人员debug用途。
> 2）在解释器中直接输入a时默认调用repr()函数，而print a则调用str()函数。
> 3）repr()的返回值一般可以用eval()函数来还原对象，通常来说有如下等式。
>
> 4）这两个方法分别调用内建的__str__()和__repr__()方法，一般来说在类中都应该定义__repr__()方法，而__str__()方法则为可选，当可读性比准确性更为重要的时候应该考虑定义__str__()方法。如果类中没有定义__str__()方法，则默认会使用__repr__()方法的结果来返回对象的字符串表示形式。用户实现__repr__()方法的时候最好保证其返回值可以用eval()方法使对象重新还原。


◆ 建议35：分清staticmethod和classmethod的适用场景

> 静态方法定义在类中，较之外部函数，能够更加有效地将代码组织起来，从而使相关代码的垂直距离更近，提高代码的可维护性。
> 类方法参数列表默认传入类型而不是类型实例，操作是对于类型而言静态方法和类方法都可以通过类名.方法名（如C.f()）或者实例.方法名（C().f()）的形式来访问。其中静态方法没有常规方法的特殊行为，如绑定、非绑定、隐式参数等规则，而类方法的调用使用类本身作为其隐含参数，但调用本身并不需要显示提供该参数动态生成了对应的类的类变量


◆ 建议36：掌握字符串的基本用法

1. 判断一个变量s是不是字符串应使用isinstance(s,basestring)，注意这里的参数是basestring而不是str。

2. 因为basestring才是str和unicode的基类，包含了普通字符串和unicode类型。

2. startswith(prefix[, start[, end]])、endswith(suffix[,start[, end]])

3. 需要注意的是*with()函数族可以接受可选的start、end参数，善加利用，可以优化性能。

4. count()能够查找子串sub在字符串中出现的次数，这个数值在调用replace方法的时候用得着。

5. find()函数族找不到时返回-1，index()函数族则抛出ValueError异常

6. *partition()函数族是2.5版本新增的方法，它接受一个字符串参数，并返回一个3个元素的元组对象。如果sep没出现在母串中，返回值是(sep, '','')；否则，返回值的第一个元素是sep左端的部分，第二个元素是sep自身，第三个元素是sep右端的部分。

7. split()有不少小陷阱，需要注意，比如对于字符串s、s.split()和s.split('')的返回值是不相同的。
   ￼
   ```python
   >>>' hello   world!'.split()￼
   ['hello', 'world!']￼
   >>>' hello   world!'.split(' ')￼
   ['', '', 'hello', '', '', 'world!']
   ```

   

8. capwords，title区别

   ```Python
   >>>hello   world!'.title()
   ' Hello   World!'
   >>>string.capwords(' hello   world!')
   'Hello World!'
   ```

◆ 建议37：按需选择sort()或者sorted()

​	sorted()比sort()使用的范围更为广泛，两者的函数形式分别如下：

​		sorted()作用于任意可迭代的对象，而sort()一般作用于列表。

​		sorted()函数会返回一个排序后的列表，原有列表保持不变；而sort()函数会直接修改原有列表，函数返回为None。


◆ 建议38：使用copy模块深拷贝对象

​	深拷贝相当于创建一个新实例，然后浅拷贝相当于增加一个该对象的引用。

​	浅拷贝，它仅仅拷贝了pizzalist里面对象的地址而不对对应地址所指向的具体内容（即具体的pizza）进行拷贝，因此	customer2中的pizzaList所指向的具体内容是和customer1中一样的


◆ 建议39：使用Counter进行计数统计

counter模块可以计算出序列对象相同元素出现的次数，并且它能够给出出现最频繁的n个元素等操作。更新方法是update移除方法是subtract

Counter(some_data).most_common(2) 
[('a', 3), (4, 2)]
当访问不存在的元素时，默认返回为0而不是抛出KeyError异常。

(Counter(some_data))['y'] 
0
update()方法用于被统计对象元素的更新，原有Counter计数器对象与新增元素的统计计数值相加而不是直接替换它们。
subtract()方法用于实现计数器对象中元素统计值相减，输入和输出的统计值允许为0或者负数。

c = Counter("success")     #Counter({'s': 3, 'c': 2, 'e': 1, 'u': 1}) 
c.update("successfully")   #'s': 3, 'c': 2, 'l': 2, 'u': 2, 'e': 1, 'f': 1, 'y': 1 

利用most_common()方法可以找出前N个出现频率最高的元素以及它们对应的次数。


◆ 建议40：深入掌握ConfigParser

那么配置项值的查找规则如下：
1）如果找不到节名，就抛出NoSectionError。
2）如果给定的配置项出现在get()方法的vars参数中，则返回vars参数中的值。
3）如果在指定的节中含有给定的配置项，则返回其值。
4）如果在[DEFAULT]中有指定的配置项，则返回其值。
5）如果在构造函数的defaults参数中有指定的配置项，则返回其值。
6）抛出NoOptionError。

巧妙利用自定义session和默认Session名之间的查找顺序，然后来实现默认Session配置根据自定义session名的替换。
通过不同的节名调用get()方法时，格式化conn_str的参数是不同的，这个规则跟上述查找配置项的规则相同。


◆ 建议43：一般情况使用ElementTree解析XML

DOM需要将整个XML文件加载到内存中并解析为一棵树，虽然使用较为简单，但占用内存较多，性能方面不占优势，并且不够

而SAX是基于事件驱动的，虽不需要全部装入XML文件，但其处理过程却较为复杂

由于ElementTree底层进行了一定的优化，并且它的iterparse解析工具支持SAX事件驱动，能够以迭代的形式返回XML部分数据结构，从而避免将整个XML文件加载到内存中，

一般情况指的是：XML文件大小适中，对性能要求并非非常严格。

GB或近似GB级别，第三方模块lxml会获得较优的处理结果。

iterparse返回一个可以迭代的由元组(时间,元素)组成的流对象，


◆ 建议47：使用logging记录日志信息

最后关于logging的使用，提以下几点建议：

1. 尽量为logging取一个名字而不是采用默认，这样当在不同的模块中使用的时候，其他模块只需要使用以下代码就可以方便地使用同一个logger，因为它本质上符合单例模式。

import logging 
logging.basicConfig(level=logging.DEBUG) 
logger = logging.getLogger( __name__ )

2. 为了方便地找出问题所在，logging的名字建议以模块或者class来命名。Logging名称遵循按“.”划分的继承规则，根是root logger，logger a.b的父logger对象为a。
   3）Logging只是线程安全的，不支持多进程写入同一个日子文件，因此对于多个进程，需要配置不同的日志文件。

◆ 建议50：利用模块实现单例模式

```python
class Singleton(object): 
   instance = None 
   def new(cls, *args, **kwargs): 
       if not cls.instance: 
          cls.instance = super(Singleton, cls).new( 
                          cls, *args, **kwargs) 
       return cls.instance 
if name == 'main': 
   s1=Singleton() 
   s2=Singleton() 
   assert id(s1)==id(s2)
```

这个方法很好地解决了前面的问题，现在基本上可以保证“只能有一个实例”的要求了，但是在并发情况下可能会发生意外

```python
class Singleton(object): 
   objs  = {} 
   objs_locker =  threading.Lock() 
   def new(cls, *args, **kv): 
      if cls in cls.objs: 
         return cls.objs[cls] 
      cls.objs_locker.acquire() 
      try: 
          if cls in cls.objs: ## double check locking 
             return cls.objs[cls] 
          cls.objs[cls] = object.new(cls) 
      finally: 
        cls.objs_locker.release()
```

利用经典的双检查锁机制，确保了在并发环境下Singleton的正确实现。

python中的模块采用的其实是天然的单例的实现方式。

- 所有的变量都会绑定到模块。
- 模块只初始化一次。
- import机制是线程安全的（保证了在并发状态下模块也只有一个实例）。

另外实现单例的还有brog思想，它提出类实例可以有无数个，但是共用类数据，从而保证了行为一致。

```python
  class Borg: 
     shared_state = {} 
     def init(self): 
        self.dict__ = self.__shared_state 
```


◆ 建议51：用mixin模式让程序更加灵活

所谓的模板方法模式就是在一个方法中定义一个算法的骨架，并将一些实现步骤延迟到子类中。

每个类都有一个\__bases__属性，它是一个元组，用来存放所有的基类。

Python语言中的基类在运行中可以动态改变。

所以当我们向其中增加新的基类时，这个类就拥有了新的方法，也就是所谓的混入


◆ 建议52：用发布订阅模式实现松耦合

订阅/发布模式是观察者模式的超集，它不关注消息是谁发布的，也不关注消息由谁处理。但有时候我们也希望某个自己的类的也能够更方便地订阅/发布消息，也就是想退化为观察者模式，


◆ 建议53：用状态模式美化代码

所谓状态模式，就是当一个对象的内在状态改变时允许改变其行为，但这个对象看起来像是改变了其类。

通过在不同的条件下将实例的方法（即行为）替换掉，就实现了状态模式。


◆ 建议55：__init__()不是构造方法

实际上__init__()并不是真正意义上的构造方法，__init__()方法所做的工作是在类的对象创建好之后进行变量的初始化。__new__()方法才会真正创建实例，是类的构造方法。

__new__()方法是静态方法，而__init__()为实例方法。

·一般情况下不需要覆盖__new__()方法，但当子类继承自不可变类型，如str、int、unicode或者tuple的时候，往往需要覆盖该方法。
·当需要覆盖__new__()和__init__()方法的时候这两个方法的参数必须保持一致，如果不一致将导致异常。

那么在什么特殊情况下需要覆盖__new__()方法呢？有以下几种情况：
1）当类继承（如str、int、unicode、tuple或者forzenset等）不可变类型且默认的__new__()方法不能满足需求的时候。

2）用来实现工厂模式或者单例模式或者进行元类编程（元类编程中常常需要使用__new__()来控制对象创建。


◆ 建议56：理解名字查找机制

Python中所有的变量名都是在赋值的时候生成的，而对任何变量名的创建、查找或者改变都会在命名空间（namespace）中进行。变量名所在的命名空间直接决定了其能访问到的范围，即变量的作用域。Python中的作用域自Python2.2之后分为局部作用域（local）、全局作用域（Global）、嵌套作用域（enclosing functions locals）以及内置作用域（Build-1n）这4种。

局部作用域：一般来说函数的每次调用都会创建一个新的本地作用域，拥有新的命名空间。

全局作用域：定义在Python模块文件中的变量名拥有全局作用域，需要注意的是这里的全局仅限单个文件，即在一个文件的顶层的变量名仅在这个文件内可见，并非所有的文件，其他文件中想使用这些变量名必须先导入文件对应的模块。当

此处嵌套作用域说明已不适用于py3
嵌套作用域：一般在多重函数嵌套的情况下才会考虑到。需要注意的是global语句仅针对全局变量，在嵌套作用域的情况下，如果想在嵌套的函数内修改外层函数中定义的变量，即使使用global进行申明也不能达到目的，其结果最终是在嵌套的函数所在的命名空间中创建了一个新的变量。

嵌套作用域：一般在多重函数嵌套的情况下才会考虑到。需要注意的是global语句仅针对全局变量，在嵌套作用域的情况下，如果想在嵌套的函数内修改外层函数中定义的变量，即使使用global进行申明也不能达到目的，其结果最终是在嵌套的函数所在的命名空间中创建了一个新的变量。

当访问一个变量的时候，其查找顺序遵循变量解析机制LEGB法则，即依次搜索4个作用域：局部作用域、嵌套作用域、全局作用域以及内置作用域，并在第一个找到的地方停止搜寻，如果没有搜到，则会抛出异常。

具体来说Python的名字查找机制如下：
1）在最内层的范围内查找，一般而言，就是函数内部，即在locals()里面查找。
2）在模块内查找，即在globals()里面查找。
3）在外层查找，即在内置模块中查找，也就是在__builtin__中查找。


◆ 建议57：为什么需要self参数

self是对对象st本身的引用

在存在同名的局部变量以及实例变量的情况下使用self使得实例变量更容易被区分。


◆ 建议58：理解MRO与多继承

关于Python多继承，经典类，深度优先，新式类，广度优先。Python 2.x中默认都是经典类，只有显式继承了object才是新式类。Python 3.x中默认都是新式类,经典类被移除，不必显式的继承object。

MRO（Method Resolution Order，方法解析顺序

在古典类中，MRO搜索采用简单的自左至右的深度优先方法，即按照多继承申明的顺序形成继承树结构，自顶向下采用深度优先的搜索顺序，当找到所需要的属性或者方法的时候就停止搜索。


◆ 建议59：理解描述符机制

 python可以动态地给自定义类添加属性和方法，但是不能用在内置类型上。
可以看到实例my_instance可以访问类属性class_attr。但与读操作有所不同，如果通过实例增加一个属性，只能改变此实例的属性，对类属性而言，并没有丝毫变化。这从下面的代码中可以得到印证。

```python
>>>my_instance.inst_attr = 'china' 
>>>my_instance.dict 
{'inst_attr': 'china'} 
>>>MyClass.dict 
dict_proxy({'dict': <attribute 'dict' of 'MyClass' objects>, ' 
    module': 'main', 'weakref': <attribute 'weakref' 
    of 'MyClass' objects>, 'doc': None, ' class _attr': 1})
```

那么，能不能给类增加一个属性呢？答案是，能，也不能。

1. 说能，是因为每一个class也是一个对象，动态地增减对象的属性与方法正是Python这种动态语言的特性，自然是支持的。

```python
>>>MyClass.class_attr2 = 100 
>>>my_instance.class_attr2 
100
```



2. 说不能，是因为在Python中，内置类型和用户定义的类型是有分别的，内置类型并不能够随意地为它增加属性或方法。

```python
>>>str.new_attr = 1 
Traceback (most recent call last): 
 File "<stdin>", line 1, in <module> 
TypeError: can't set attributes of built-1n/extension type 'str' 

>>>setattr(str, 'new_attr', 1) 
Traceback (most recent call last): 
 File "<stdin>", line 1, in <module> 
TypeError: can't set attributes of built-1n/extension type 'str'
```




◆ 建议60：区别__getattr__()和__getattribute__()方法

__getattr__()和__getattribute__()都可以用做实例属性的获取和拦截（注意，仅对实例属性（instance variable）有效，非类属性），__getattr__()适用于未定义的属性，即该属性在实例中以及对应的类的基类以及祖先类中都不存在，而__getattribute__()对于所有属性的访问都会调用该方法。

需要注意的是__getattribute__()仅应用于新式类。

当访问一个不存在的实例属性的时候就会抛出AttributeError异常。这个异常是由内部方法__getattribute__(self,name)抛出的，因为__getattribute__()会被无条件调用，也就是说只要涉及实例属性的访问就会调用该方法，它要么返回实际的值，要么抛出异常

实际上_getattr__()方法仅如下情况下才被调用：属性不在实例的__dict__中；属性不在其基类以及祖先类的__dict__中；触发AttributeError异常时（注意，不仅仅是__getattribute__()引发的AttributeError异常，property中定义的get()方法抛出异常的时候也会调用该方法）。

无穷递归是覆盖__getatt__()和__getattribute__()方法的时候需要特别小心。

另外关于__getattr__()和__getattribute__()有以下两点提醒：
1）覆盖了__getattribute__()方法之后，任何属性的访问都会调用用户定义的__getattribute__()方法，性能上会有所损耗，比使用默认的方法要慢。
2）覆盖的__getattr__()方法如果能够动态处理事先未定义的属性，可以更好地实现数据隐藏。

__getattribute__()总会被调用，而__getattr__()只有在__getattribute__()中引发异常的情况下才会被调用。


◆ 建议61：使用更为安全的property

property到底有什么优势呢？为什么要有这个特性呢？property的优势可以简单地概括为以下几点：
1）代码更简洁，可读性更强。这条优势是显而易见的，显然obj.x+=1比obj.set_value(obj.get_value()+1)要更简洁易读，而且对于编程人员来说还少敲了几次键盘。
2）更好的管理属性的访问。property将对属性的访问直接转换为对对应的get、set等相关函数的调用，属性能够更好地被控制和管理

）代码可维护性更好。property对属性进行再包装，以类似于接口的形式呈现给用户，以统一的语法来访问属性，当具体实现需要改变的时候（如改变某个内部变量，或者赋值或取值的计算发生改变），访问的方式仍然可以保留一致。

）控制属性访问权限，提高数据安全性。如果用户想设置某个属性为只读，我们来看看使用property如何满足这个需求。


◆ 建议63：熟悉Python对象协议

对象协议说白了就是python的魔法方法的调用。
比如在字符串格式化中，如果有占位符%s，那么按照字符串转换的协议，Python会去自动地调用相应对象的__str__()方法

比如在字符串格式化中，如果有占位符%s，那么按照字符串转换的协议，Python会去自动地调用相应对象的__str__()方法


◆ 建议65：熟悉 Python 的迭代器协议

1）实现__iter__()方法，返回一个迭代器。
2）实现next()方法，返回当前的元素，并指向下一个元素的位置，如果当前位置已无元素，则抛出StopIteration异常。

其实for语句就是对获取容器的迭代器、调用迭代器的next()方法以及对StopIteration进行处理等流程进行封装的语法糖（类似的语法糖还有in/not it语句）

迭代器最大的好处是定义了统一的访问容器（或集合）的统一接口，所以程序员可以随时定义自己的迭代器，只要实现了迭代器协议就可以。除此之外，迭代器还有惰性求值的特性，它仅可以在迭代至当前元素时才计算（或读取）该元素的值，在此之前可以不存在，在此之后可以销毁，也就是说不需要在遍历之前事先准备好整个迭代过程中的所有元素，所以非常适合遍历无穷个元素的集合（如斐波那契数列）或巨大的事物（如文件）。


◆ 建议66：熟悉 Python 的生成器

如果一个函数，使用了yield语句，那么它就是一个生成器函数

当调用生成器函数时，它返回一个迭代器，不过这个迭代器是以生成器对象的形式出现的。

每一个生成器函数调用之后，它的函数体并不执行，而是到第一次调用next()的时候才开始执行


◆ 建议69：对象的管理与垃圾回收

Python中内存管理的方式：Python使用引用计数器（Reference counting）的方法来管理内存中的对象，即针对每一个对象维护一个引用计数值来表示该对象当前有多少个引用。当其他对象引用该对象时，其引用计数会增加1，而删除一个对当前对象的引用，其引用计数会减1。只有当引用计数的值为0的时候该对象才会被垃圾收集器回收，因为它表示这个对象不再被其他对象引用，是个不可达对象。引用计数算法最明显的缺点是无法解决循环引用的问题，即两个对象相互引用。

对于由循环引用而导致的内存泄露的情况，有没有办法进行控制和管理呢？实际上Python自带了一个gc模块，它可以用来跟踪对象的“入引用（incoming reference）”和“出引用（outgoing reference）”，并找出复杂数据结构之间的循环引用，同时回收内存垃圾。

实际上当存在循环引用并且当这个环中存在多个析构方法时，垃圾回收器不能确定对象析构的顺序，所以为了安全起见仍然保持这些对象不被销毁。而当环被打破时，gc在回收对象的时候便会再次自动调用__del__()方法。


◆ 建议81：利用cProfile定位性能瓶颈

profile是Python的标准库。可以统计程序里每一个函数的运行时间，并且提供了多样化的报表，而cProfile则是它的C实现版本，剖析过程本身需要消耗的资源更少

timeit除了有非常友好的编程接口，也同样提供了友好的命令行接口。


◆ 建议84：掌握循环优化的基本技巧

1）减少循环内部的计算。

2）将显式循环改为隐式循环

3）在循环中尽量引用局部变量。在命名空间中局部变量优先搜索，因此局部变量的查询会比全局变量要快，当在循环中需要多次引用某一个变量的时候，尽量将其转换为局部变量。

4）关注内层嵌套循环。在多层嵌套循环中，重点关注内层嵌套循环，尽量将内层循环的计算往上层移。


◆ 建议91：使用 Cython 编写扩展模块

Cython通过给Python代码增加类型声明和直接调用C函数，使得从Python代码中转换的C代码能够有非常高的执行效率。

它的优势在于它几乎支持全部Python特性，也就是说，基本上所有的Python代码都是有效的Cython代码

除此之外，Cython支持使用decorator语法声明类型，甚至支持专门的类型声明文件，以使原有的Python代码能够继续保持独立，这些特性都使它得到广泛应用

安装Cython非常简单，使用pip能够很方便地安装。

pip install 
–U cython

Cython很体贴地提供了无需显式编译的方案：pyximport

只要将原有的Python代码后缀名从.py改为.pyx即可。

Cython的两大技能：类型声明和直接调用C函数。