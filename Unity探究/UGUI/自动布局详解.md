## 初步了解

Unity在其官方手册[UI Auto Layout]( https://docs.unity3d.com/Packages/com.unity.ugui@1.0/manual/UIAutoLayout.html )中有关于自动布局的介绍，这里简单做些提要。

一句话简单的来概括UGUI的自动布局系统：它是基于基础Rect Transform的布局系统，可配置化地应用于小型UI元素或所有UI元素上，使它们能够更加结构化得在布局上发生变化。

### 核心概念

- 布局元素：即拥有RectTransform组件，或一些特定组件的UI对象。
- 布局控制器：通过布局元素提供的布局信息，统一地调整布局元素的实际布局。

布局元素拥有布局数据，但是不会直接修改自己的布局，而是由布局控制器通过布局数据来计算并修改。

**内置的布局控制器：**

- ContentSizeFitter / AspectRatioFitter：控制自身
- 各种LayoutGroup：控制子元素。

ContentSizeFitter通过直接读取自身LayoutElement数据来管理自身尺寸大小；AspectRatioFitter控制长宽比例缩放。

LayoutGroup确定Group中的子UI布局/大小的基本原则如下：

在空间充裕的情况下，先按最小尺寸分配 ，->  最优尺寸  ->  灵活尺寸。

**内置的布局元素：**

- LayoutElement：用于指定布局的组件，它可以重载布局空控制器已经计算好的尺寸，可以起到微调或指定布局数据的作用。
- 各种LayoutGroup准确的说既是布局控制器又是布局元素，子LayoutGroup计算好的数据可以向上传递。

### 自动布局原理

布局管理器 --> 布局元素 --> 获取布局数据-->计算布局数据 --> 应用到布局管理器附着对象及其子对象（注意顺序）

## 技术细节

### 自定义布局接口

- ILayoutElement： 该组件将被自动布局系统视为布局元素。 
- ILayoutGroup： 期望该组件驱动其子级的Rect转换。 
- ILayoutSelfController： 期望它驱动自己的**RectTransform**。 

### 布局计算

计算并执行布局的顺序概括来说是这样的：

- 先由布局元素计算布局中的最小、首选、灵活宽度。这个过程是从子节点向父节点逐步进行的，以便父节点计算时考虑子节点信息。
- 然后通过布局控制器来统筹计算布局元素的实际布局。这个过程是由父节点向子节点逐步进行的，因为子项的布局数据计算及分配需要基于父节点中可用区域。
- 另外，UGUI自动布局首先评估宽度，然后才评估高度。 因此，计算出的高度可能取决于宽度，但是计算出的宽度永远不会取决于高度。 

这里有个注意点：布局管理器在计算布局数据时只会考虑其下的以及子节点数据。

### 修改布局属性

由于布局控制器会自动计算布局，所以此时不应该让自动计算的布局数据能被手动修改，因此 UGUI 中引入了**Driven Transform Properties**, 这个数据只能由布局控制器去修改。

除了避免手动修改，引入Driven Transform Properties概念最大的用处就是将计算并应用布局的任务全权委托给布局控制器，这样就解放了关注点。

### 触发布局重建

当组件上的属性改变以致于当前布局不在有效时，会触发重新布局，但是不是立即触发，而是在当前帧的末尾（渲染之前），这样避免统一帧内多次布局导致性能浪费。

## 进一步探索

接下来需要继续深入探究以下几点问题：

- 各种LayoutGroup准确的说既是布局控制器又是布局元素？
- **Driven Transform Properties** 操作数据的流程？
- 就宽度布局计算详细解释一下流程？

