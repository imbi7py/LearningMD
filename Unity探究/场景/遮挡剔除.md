**什么是Occlusion Culling（遮挡剔除）？**
遮挡剔除， 当一个物体被其他物体遮挡住而不在摄像机的可视范围内时不对其进行渲染。.遮挡剔除在3D图形计算中并不是自动进行的。因为在绝大多数情况下离 camera 最远的物体首先被渲染，靠近摄像机的物体后渲染并覆盖先前渲染的物体(这被称为重复渲染"overdraw"). 遮挡剔除不同于视锥体剔除. 视锥体剔除只是不渲染摄像机视角范围外的物体而对于被其他物体遮挡但依然在视角范围内的物体，则不会被剔除. 注意当你使用遮挡剔除时你依然受益于视锥体剔除（Frustum Culling）
![](http://upload-images.jianshu.io/upload_images/3806085-63c0bf3905570bea.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240) 场景渲染无遮挡剔除
![](http://upload-images.jianshu.io/upload_images/3806085-99426b0343375208.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)场景渲染带遮挡剔除

**遮挡剔除是如何工作的？**
遮挡剔除的运行将通过在场景中**使用一个虚拟的摄像机**来创建一个物体潜在可视性**状态（set）的层级**。 这些数据可以实时让每个摄像机来确定什么能看见什么看不见。通过这些数据，Unity 将确定只把可以看见的物体送去渲染。这将降低 绘制调用(draw calls) 的数量并增加 游戏的运行效率。

遮挡剔除的数据由单元格（cells）组成， 每个单元格是在整个场景的包围体积的一部分，单元格来自一个二叉树（ binary tree），遮挡剔除使用两棵树， 一个给 View Cells (静态物体) ，另一个给 Target Cells (移动物体)。 View Cells 映射到一个定义静态可视物体的索引列表 （精确剔除后的静态物体）。

非常重要的一点是在创建你的物体时要随时注意，因为你需要在**物体的大小和单元格的大小间取得一个好的平衡**. 理想情况下,不应该有相比于物体，太小的单元格，但同样，物体不应该覆盖许多单元格.有时你可以通过将大的物体拆成几个部分来改进遮挡剔除效果. 然而，你仍然能够将小的物体合并在一起，来降低绘制调用次数（draw calls）， 在它们都属于同一个小单元格的时候， 遮挡剔除将不起作用。单元格的集合和可视信息确定哪些单元格是可见的，被认为是 PVS (潜在可视集合Potentially Visible Set)。

**如何设置设置遮挡剔除？**
为了使用遮挡剔除 需要进行相关的手动设置。首先，你关卡中的几何体必须被分割成合理大小的块。这也有助于布置关卡中小块的，明确界定的区域 被其他大物体遮挡（例如墙,建筑物）。这意味着每个单独的网格根据遮挡数据确定是否渲染。所以如果你有一个物体包含了房间里的所有家具，那么所有的家具要么全渲染，要么全不渲染。 使每个家具都有自己的网格，这会有不一样的感觉，那么可以根据摄像机的视点，各个物体可以单独地被剔除。

在检视面板（Inspector） 你需要标识（tag） 所有需要应用遮挡剔除的场景物体。最快的方法是选择多个想要遮挡计算的物体，然后标记它们为Occlusion Static 和 Occludee Static。
![](http://upload-images.jianshu.io/upload_images/3806085-21d7676701bf1415.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)
为遮挡标记物体
我应该在什么时候使用Occludee Static？***透明物体不能遮挡，以及小物件，都不可能阻挡其他的东西，应标记为Occludees，但不遮挡***。这意味着它们将被视为能被其他物体遮挡，但不会被视为作为遮挡物自身，这将有助于减少计算量。

**遮挡剔除窗口中如何设置？**
首先打开遮挡剔除窗口(Window->Occlusion Culling)。在遮挡剔除窗口，可以使用遮挡物网格和遮挡区域。
**—>Object选项卡**
Screne Filter 可以选择编辑的对象类型，选中对象后可以调整其静态标识。
![](http://upload-images.jianshu.io/upload_images/3806085-bfd172ddff07541b.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)
注意：
1.如果你没有创建遮挡区域，遮挡剔除将默认应用到整个场景。
2.***每当相机在遮挡区域之外，遮挡剔除将不被应用***。重要的是这种遮挡区域覆盖的地方要有相机，但如果遮挡区域太大，会导致更多烘焙开销。
3.Occlusion Areas应用于要实现遮挡的运动物体。（转另一篇）
**—>Bake选项卡**
![](http://upload-images.jianshu.io/upload_images/3806085-501421ba7c447c4c.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)
    这里可以设置物体遮挡的属性：
       **->Smallest Occluder**: 最小遮挡物的尺寸（能遮挡其他物体的最小尺寸，任何小于这个尺寸的背后物体将被遮挡）
**->Smallest Hole**: 该值表示相机应该看到的几何图形之间的最小间隙。
**->Backface Threshold**：Unity的遮挡使用数据大小优化，通过测试背面减少不必要的细节。默认值为100是强大的，不会从数据集中删除背面。值为5将根据具有可见背面的位置积极减少数据。这个想法通常，有效的摄像机位置通常不会看到许多背景 - 例如，地形下面的视图，或者您不应该能够到达的固体对象中的视图。在阈值低于100的情况下，Unity将完全从数据集中删除这些区域，从而减少遮挡的数据大小。

在烘烤标签的底部是清除和烘培按钮。点击烘培按钮开始生成遮挡剔除数据。生成数据后，您可以使用“可视化”选项卡来预览和测试遮挡剔除。如果您对结果不满意，请点击清除按钮删除先前计算的数据，调整设置，然后再烘培。
**—>Visualization选项卡**
![](http://upload-images.jianshu.io/upload_images/3806085-d6e4d2c6c9ff381a.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)
可以通过选择查看所有物体或者只看摄像机看到的物体，来检查剔除效果。


遮挡剔除消除drawcall的效率是非常高的，在一些大场景中往往能降低未优化时drawcall数量的50%甚至更多。