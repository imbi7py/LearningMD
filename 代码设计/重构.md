[TOC]

- 《重构-Ruby版》- 记录

## 得知

### 常见重构方式

#### 分层

- 允许逻辑共享
- 分开解释意图和实现
- 隔离变化
- 封装条件逻辑

### 重构难题

#### 接口重命名

接口重命名要注意其影响，如果影响不受掌控，比如接口作为外部服务发布出去了，那肯定不能直接改名，可以通过装饰模式对内部接口进行重新封装再由外部接口调用。

### 不应该重构的情况

- 既有代码实在太混乱，与其重构花费时间理解原代码不如重新实现。
- 重构应该在时间充裕的情况下进行

### 预先设计和重构驱动

很难说哪种更好，但是可以确定的是，没必要过分强调前期的预先设计。虽然有经验者的预先设计可以为后续重构降低难度，但是如果把重点放在这上面，那前期压力太大了；如果重点放在重构上（预先设计还是要有，但不必面面俱到），那么只需要不断完善预先设计方案。

### 代码的坏味道及解决思路

- 重复的代码：提炼、继承、分割差异。
- 过长函数：拆分逻辑；临时变量问题（过多则用函数获取替代；函数获取复杂则用解释性变量替代）；条件表达式如果太长考虑拆分除去并且提炼分支。
- 臃肿的类：提炼新类；扩展子类/提炼超类；拆分视图层和业务逻辑层；数据对象取代零散的变量；常量取代数字。
- 过长的参数列表：引入参数对象，封装参数列表。
- 霰弹式修改（一处修改，处处修改）：存在重复代码，提炼变化。
- 发散式变化（ 一个类受多种变化的影响 ）：结构不合理，应该拆分变化；应对这个问题的设计模式有策略模式，访问者模式。
- 重复的switch语句：提炼成函数、多态、映射表。
- 平行继承体系（某个类增加一个子类必须给另一个类相应地增加一个子类）：一个继承体系引用另一个继承体系的实例；迁移对象函数或字段。
- 过度耦合的调用链：将调用关系隐藏到对象内部。
- 异曲同工的类：提炼超类。
- 相同名字的重载函数：根据不同目的重命名。
- 不完美又无法直接修改的类/类库：编写扩展函数，或进一步封装该函数；创建该类的子类以扩展特性。
- 数据类：避免字段能够直接被操作，封装获取和修改途径。
- 是子类却只重写了少数超类内容，甚至不想继承超类函数：思考是否有必要继承，不然就用组合替代继承；超类是否够抽象。
- 函数中有过多的注释：考虑拆分函数，具象化出小函数，并用函数名取代注释。

### 重构基本技巧

- 小步前进，频繁测试

## 躬行

一般的重构流程：

- 跑一遍现有功能，形成大体印象
- 查阅功能设计文档，形成整体印象
- 整理旧代码结构，为重构做准备
- 根据新规范及重构原则，重构旧代码