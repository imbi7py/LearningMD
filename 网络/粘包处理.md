[TOC]

#### 简介

**粘包现象**

首先我们要知道什么是粘包：

我们首先要知道，粘包是对于TCP来说的，UDP是不存在粘包一说的，那么TCP在传输数据的过程的特点是什么呢：

> 1 会将数据量较小，且发送时间间隔较短的的数据一起打包发送，那么这里所讲的时间较短是相比较网络延迟来说的，
> 比如我们两次发送间隔为0.00001秒，那么网络延迟为0.001，这个时候两次的数据就会打包发送，这是一种优化机制。
>
> 2 TCP协议发送数据时，是源源不断的发送，像水流一样，因此TCP又叫流式协议。

#### 产生场景

**缓存发送**(发送端需要等缓冲区满才发送出去，造成粘包)

服务端在接收消息时是有一个最大限制的=>conn.recv(1024),1024表示1024个bytes。那么如果我们一次传输的数据超过了1024bytes，剩余的数据会存在我们接收端计算机操作系统缓存中，也就是说，接收方并不知道发送方传输了多少数据，所以这个时候问题就出现了，发送方引起的粘包是由TCP协议本身造成的，TCP为提高传输效率，<u>发送方往往要收集到足够多的数据后才发送一个TCP段</u>。若连续几次需要send的数据都很少，通常TCP会根据优化算法把这些数据合成一个TCP段后一次发送出去，这样接收方就收到了粘包数据。

所以我们在程序中调用SOCKET的send发送了数据后操作系统有可能缓存了起来，等待后续的数据一起发送，而不是立即发送出去。send的文档中对此也有说明。

**分包发送**（接收方不及时接收缓冲区的包，造成多个包接收）
网络传输的概念中有**MTU（最大传输单元）**的概念，也即是网络中一个数据包最大的长度。如果要发送超过这个长度的数据包，就需要<u> 分包发送</u>。当调用SOCKET的send发送超过MTU的数据包时，操作系统提供的SOCKET实现会自动将这个数据包分割成几个不超过MTU的数据包发送。



当出现这些上面这些情况的时候，**接收端就会发现接收到的数据和发送的数据的次数不一致。**这个就是第二种粘包现象。

简单说下MTU：

>这里举一个具体的例子说明IP包分片的原理。以太网的MTU值是1500 bytes，假设发送者的协议高层向IP层发送了长度为3008 bytes的数据报文，则该报文在添加20 bytes的IP包头后IP包的总长度是 3028 bytes，因为3028 > 1500，所以该数据报文将被分片，
>
>注意：分片时仅仅对上层的数据进行分片，不需要对原来的IP首部分片，所以要分片的数据长度只有3008，而不是3028. 这特别容易出错。
>
>分片过程如下：
>
>1. 第一片1500 bytes= 1480 bytes(真实数据) + 20 bytes(IP首部)。
>
>2. 第二片1500 bytes= 1480 bytes(真实数据) + 20 bytes(IP首部)。
>
>3. 第三片68 bytes=  48 bytes(剩余真实数据) + 20 bytes(IP首部)。
>
>从以上分片例子可以看出第一、二个分片包组成的IP包的长度都等于MTU即1500 bytes。

#### 解决
当我们传输如文件这种数据时，流式的传输非常适合，但是当我们传输指令之类的数据结构时，流式模型就有一个问题：<u>**接收端不知道发送端将要传送的字节流的长度。**</u>

所以解决粘包的方法就是围绕，如何让发送端在发送数据前，把自己将要发送的字节流总大小让接收端知晓，然后接收端来一个死循环接收完所有数据。

**1.短连接**
最简单的方法就是短连接，也就是需要发送数据的时候建立TCP连接，发送完一个数据包后就断开TCP连接，这样接收端自然就知道数据结束了。 
但是这样的方法因为会多次建立TCP连接，性能低下。随便用用还可以，只要稍微对性能有一点追求的人就不会使用这种方法。

**2.长连接**
使用长连接能够获得更好的性能但不可避免的会遇到 **<u>  如何判断数据结构的开始与结束的问题。</u>**
而此时的处理方式根据数据结构的类型分两种方式。

​	**2.1.定长结构**
​	因为粘包问题的存在，接收端不能想当然的以为发送端一次发送了多少数据就能一次收到多少数据。如果发送端发送了一个固定长度的数据结构，接收端必须每次都严格判断接收到数据的长度，当收到的数据长度不足时，需要再次接收数据，直到满足长度，当收到的数据多于固定长度时，需要截断数据，并将多余的数据缓存起来，视为长度不足需要再次接收处理。

​	**2.2.不定长结构**
​	定长的数据结构是一种理想的情况，<u> 真正的应用中通常使用的都是不定长的数据结构。</u> 
对于发送不定长的数据结构，简单的做法就是**选一个固定的字符作为数据包结束标志**，接收到这个字符就代表一个数据包传输完成了。 
<u> 但是这只能应用于字符数据，因为二进制数据中很难确定结束字符到底是结束还是原本要传输的数据内容</u>（使用字符来标识数据的边界在传输二进制数据时时可以实现的，只是实现比较复杂和低效。想了解可以参考以太网传输协议）。 
**目前最通用的做法是在每次发送的数据的固定偏移位置写入数据包的长度。** 
接收端只要一开始读取固定偏移的数据就可以知道这个数据包的长度，接下来的流程就和固定长度数据结构的处理流程类似。

所以对于处理粘包的关键在于提前获取到数据包的长度，无论这个长度是提前商定好的还是写在在数据包的开头。 
因为在每次发送的数据的固定偏移位置写入数据包的长度的方法是最通用的一种方法，所以对这种方法实现中的一些容易出错误的地方在此特别说明。

- 通常我们使用2~4个字节来存放数据长度，多字节数据的网络传输需要注意字节序，所以要注意接受者和发送者要使用相同的字节序来解析数据长度。
- 每次新开始接收一段数据时不要急着直接去解析数据长度，先确保目前收到的数据已经足够解析出数据长度，例如数据开头的2个字节存储了数据长度，那么一定**确保接收了2个字节以上的数据**后才去解析数据长度。 
  如果没做到这一点的服务器代码，收到了一个字节就去解析数据长度的，结果得到的长度是内存中的随机值，结果必然是崩溃的
- 有些非法客户端或者有bug的客户端可能会发出错误的数据，导致解析出的数据长度异常的大，一定要对解析出的数据**长度做检查**，事先规定一个合适的长度，一旦超过果断关闭SOCKET，避免服务器无休止的等待下去浪费资源。 
  不要妄想说自己写的客户端不会出错，哪怕客户端不出错，只要其他任何一个使用TCP的客户端写错了端口，也足以让你崩溃，毕竟管得了自己管不了别人
- 处理完一个完整的数据包后一定**检查是否还有未处理的数据**，如果有的话要对这段多余的数据再次开始解析数据长度的过程。不要忙着去继续接受数据。 

  这应该是最常犯的一个错误，很多人以为完整的处理了一个数据包后就万事大吉，可以重新开始处理流程，但是别忘了，收到的数据有可能带着下一个数据包的数据，别把他们忘掉

**总结**

TCP中的粘包的处理应该是任何一个网络编程人员都必须掌握的技能，如果对粘包问题没有任何的了解那么就谈不上所谓的精通、掌握SOCKET编程。

